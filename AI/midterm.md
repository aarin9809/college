인공 지능
- 인간이 가진 지적 능력을 컴퓨터를 통해 구현 하는 기술

머신 러닝
- 데이터와 알고리즘을 통해 컴퓨터를 학습 시켜 인공 지능의 성능을 향상 시키는 기술

딥 러닝
- 신경망을 이용한 머신 러닝 방법.
여러층으로 이루어진 신경망을 사용.

--------------------------------------------

지도학습

--------------------------------------------

회귀 : 입력과 출력이 실수
분류 : 입력을 레이블로 분할. 출력이 이산적

--------------------------------------------

머신러닝 과정
1. 데이터 확보
2. 데이터 정제
3. 모델 학습
4. 모델 평가
5. 예측에 사용

--------------------------------------------

데이터는 두가지로 나뉘는데, '학습 데이터' 와 '테스트 데이터'로 나뉜다.

-------------------------------------------------------------------------------------------------------------------

인공지능
- 인간이 가진 지적 능력을 컴퓨터를 통해 구현 하는 기술

머신러닝
- 데이터와 알고리즘을 통해 컴퓨터를 학습 시켜 인공지능의 성능을 향상 시키는 기술

딥 러닝
- 신경망을 이용한 머신 러닝 방법
- 여러 층으로 이루어진 신경망을 사용.

회귀 : 입력과 출력이 실수
분류 : 입력을 레이블로 분할. 출력이 이산적.

머신러닝의 과정
1. 데이터 확보
2. 데이터 정제
3. 모델 학습
4. 모델 평가
5. 예측에 사용
인공지능 : 지적능력, 컴퓨터 구현
머신러닝 : 알고리즘을 통해 학습시켜 인공지능의 성능을 향상
딥 러닝 : 인공 신경망을 이용한 방법

머신러닝
지도학습: 회귀, 분류, 판단트리

지도학습 : 정답을 주어 학습한다.

회귀 : 입출력이 실수
분류 : 입력을 2개 이상의 클래스로 분할, 분류

머신러닝 과정
1. 데이터 확보
2. 데이터 정제
3. 모델 학습
4. 모델 평가
5. 예측 사용

데이터 분류
1. 훈련 데이터 : 훈련용 데이터 해당 데이터를 통해선 모델의 성능을 평가하기 부적절함.
2. 테스트 데이터 : 모델이 학습한 적 없는 데이터, 해당 데이터를 통해서 모델의 성능을 평가할 수 있음.

예측 : 붓꽃 데이터(선형 판별 모델), 필기체 이미지(knn)

선형 회귀 : 회귀는 데이터를 잘 설명하는 함수를 찾는 것인데 이 함수를 Y = wX + b로 표현할 때 선형회귀라고 함.

경사하강법 : 경사의 반대 방향으로 계속 이동시켜 극값에 이를 때까지 반복
다중선형회귀 : Y = w1 x X1 + w2 x X2 + b를 찾으면 됨

평균 제곱 오차(MSE) : 예측값 - 정답의 평균

퍼셉트론 : 가중치 + 바이어스

step function : 값이 0 이하면 0, 이상이면 1로 변경
ReLU : 0 이하는 0으로 0 초과는 그 수 그대로 사용

다층 퍼셉트론 : xor 정도로 간단한 문제도 해결 못함. -> 입력층과 출력층 사이에 은닉층이 존재함.

순방향 패스 : 입력 신호가 입력층에서 은닉층을 지나 출력층으로 전파되는 과정을 나타내며 입력 값을 주어졌을 때 출력되는 값을 순방향 패스라고 함.

역방향 패스 : 가중치들을 수정할 때는 역방향으로 전파시켜 경사하강법을 통해 학습시킴. 다층 퍼셉트론의 최적화 과정.

-----------------------------------------------------------------------------------------

Q1. 다음의 코드에서 Autowire.BYTYPE에 기반하여 자동주입이 되는 과정에 대해 서술하시오.
A. BY TYPE은 타입에 기반한 자동주입이기 때문에, MainClass.java에서 TestBean1 class를 가진 객체를 호출하면, 프레임워크가 TestBean1에 있는 property의 타입을 확인하고, BeanConfigClass에 등록된 객체 중 같은 타입의 객체를 자동으로 주입한다.

Q2. 다음의 코드에서 어노테이션에 기반하여 자동주입 되는 과정에 대해 서술하시오.
A. Autowired 어노테이션에 의해 TestBean1.java의 data1, data2 property에 객체를 주입하기 위해 프레임워크가 DataBean1 타입의 객체를 탐색한다. beans.xml에 등록된 DataBean1 타입의 객체가 두개이기 때문에, Qualifier 어노테이션을 통해 명시된 객체의 이름을 활용해 알맞은 객체를 찾아 주입한다.

Q3. 다음의 xml 코드를 자바 코드상에서 setter 메서드를 활용한 자동 주입 코드로 작성하고, 작성한 코드의 근거에 대해 서술하시오.
A. Configuration 어노테이션으로 BeanConfigClass.java 파일이 빈 등록을 위한 자바 파일임을 프레임워크에 명시하고, Bean 어노테이션으로 Bean 정보에 대해 등록했다. 그 후, setter 메서드를 통해 TestBean1에 값을 주입한다.

Q4-1. MainClass.java의 출력 결과에 대해 BeanConfigClass, TestBean1 각각에 올바른 어노테이션을 추가하시오.
A. @Configuration, @ComponentScan(basePackages = {"kr.co.inhatcspriing.beans", "kr.co.inhatcspring.advisor"}), @EnableAspectJAutoProxy

Q4-2. Advisor.java에 '모든 패키지의 모든 크래스에 대해 method1이라는 이름을 가지고 있으며 매개변수를 0개 이상인 메서드가 호출될 때 weaving 될 after advice'를 정의하는 코드를 작성하시오.
A. @Aspect, @Component, @After("execution(void kr.co.inhatcspring.*.*.method1(..))") public void afterMethod() { System.out.println("afterMethod 호출");

Q4-3. 4-1,4-2에서 작성한 코드의 작성 이유에 대해 서술 하시오.
A. Configuration 어노테이션으로 BeanConfigClass.java가 객체 등록을 위한 파일임을 명시하고, ComponentScan 어노테이션으로 객체 등록을 위한 경로를 지정한다. 자동으로 AOP 설정을 하기 위해 EnableAspectJAutoProxy 어노테이션을 명시하고, TestBena1.java에는 Component scan을 위해 Component 어노테이션을 작성한다.
 AdvisorClass.java에는 AOP 설정을 위해 Aspect 어노테이션과 Component scan을 위한 Component 어노테이션을 작성한다. After 어노테이션으로 아래에 작성될 메서드가 After advice임을 명시하고, 아스트리스크를 통해 모든 패키지의 모든 클래스 아래에 method1이라는 이름의 메서드에 대해 동작할 것을 정의한다. 매개 변수의 자리에 ..을 작성해 매개변수가 0개 이상인 메스드임을 명시했다.

Q5. 국제화 지원 등 문자열에 관련된 다양한 기능을 제공하며, 기업 실무용으로 사용되는 container를 beans.xml 파일이 패키지 내부에 위치할 경우 어떤 메서드로 여는가?
A. ClassPathXmlApplicationContext

Q6. 다음의 MainClass.java에서 객체가 생성되는 횟수와 생성 순서, 그 이유에 대해 서술하시오.
A. 4번, bean2 -> bean1 -> bean3 -> bean3
bean2는 lazy-init이 false(default)기 때문에, xml파일이 로딩될 때 객체가 가장 먼저 생성된다.
bean1은 lazy-init이 true이기 때문에 객체가 getbean으로 호출될 때 생성된다.
bean3는 lazy-init이 true고, scope가 prototype이기 때문에 객체가 getbean으로 호출될 때 생성되며, 그 후에 호출될 때마다 새로 생성된다.
