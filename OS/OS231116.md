# 시험에 나올듯
## 디스크 스케줄링 알고리즘
#### FCFS
풀이 -> 트랙 접근 순서는 디스크 대기 큐 순서대로 나열. 
그 후에 현 헤드 위치에서 디스크 대기 큐 첫번째부터 오차 계산. ex) 98 - 53 = 45

#### SSTF
풀이 -> 현 헤드 위치의 다음꺼부터 점찍힌 순서대로 가면서 각 헤드간 오차를 계산.
ex) 65 - 53 = 12

#### SCAN(이동방향이 생김)
풀이 -> 현 헤드 위치의 다음꺼부터 점찍힌 순서대로 가면서 각 헤드간 오차를 계산.
ex) 53 - 37 = 16, 37 - 14 = 23 ...

#### C-SCAN(이동방향이 생김)
풀이 -> 현 헤드 위치의 다음꺼부터 점찍힌 순서대로 가면서 각 헤드간 오차를 계산.
ex) 65-53 = 12, 67 - 65 = 2 ...

#### N-Step SCAN(이동방향이 생김)
풀이 -> 98, 183, 37, 36, 122, 14, 124, 65, 67
37과 36은 중간에 난입한 숫자. 고로
트랙 접근 순서 = 14 - 65 - 67 - 98 - 122 - 124 - 183 - 37 - 36 이 됨.
헤드 이동거리 = 39 - 51 - 2 - 31 - 24 - 2 - 59 - 146 - 1 이 됨.

#### 에센바흐 기법
* 은 헤드는 C-SCAN 알고리즘처럼 움직이는데 예외로 모든 실린더는 그 실린더에 요청이 잇든지 없든지
전체 트랙이 한바퀴 회전할 동안에 서비스를 받는 기법

#### SLTF 스케줄링
* 은 회전 시간의 최적화를 위해 구현된 기법
* 섹터 큐잉 이라고 부르고 실린더 내의 여러 트랙에 대한 많은 요청이 발생
* 모든 요청은 디스크 주위의 섹터 위치에 따라 대기 행렬에 정렬되고 가장 가까운 섹터가 우선적으로 서비스 받는 기법

# 시험에 나올듯

## CPU 스케줄링

### 목적
* CPU 스케줄링 정책을 정할 때는 시스템과 사용자의 두 가지 측면에서 목적을 고려하여 스케줄링을 함
  * CPU 스케줄링의 목적은 서로 상반될 수도 있음
  * 특정 프로세스가 응답 시간을 최소화하기 위하여 CPU를 계속 할당하게 되면 전체적인 처리 능력이 떨어지며, 중
    요한 프로세스에게 우선권을 계속 부여하다 보면 무한 대기가 되는 프로세스가 발생할 수도 있음
1. 공정한 스케줄링 : 무한정으로 스케줄링이 지연되면 안 된다.
2. 처리량의 극대화 : 프로세스들은 가능한 한 단위 시간당 처리량을 최대화하여야 함
3. 응답시간 최소화 : 가능한 한 최대한 응답시간을 빠르게 한다. 응답 시간과 자 이용간의 조화로운 운영
4. 반환시간 예측 가능 : 처리시간을 예측할 수 있어야 한다.
5. 균형 있는 자원의 사용 : 유휴상태의 자원에게 더 나은 서비스 제공.
6. 실행의 무한연기 배제 및 우선 순위제

CPU 스케줄링 결정의 4가지 조건
1. 프로세스가 실행 상태에서 대기 상태로 전환될 때
2. 프로세스가 실행상태에서 준비 상태로 전환될 때
3. 프로세스가 대기 상태에서 준비 상태로 전환될 때
4. 프로세스가 수행을 마치고 종료될 때

CPU 스케줄링 결정 기준(고려사항)
1. 입출력 위주와 처리 위주 프로세스의 적절한 혼용과 프로세스의 작업형태 고려
2. 우선순위, 명령 수행시간, 잔여 실행시간을 복합적으로 고려하여 결정하여야 함.
3. CPU 스케줄링의 정책 결정 및 스케줄링 알고리즘을 구현하고자 할 때 다음과 같은 사항을 기준으로 고려해야 함.

- 프로세스의 I/O 사용 및 CPU 사용 비율의 적절한 혼합
  - 연산위주의 프로세스인가? 또는 I/O위주의 프로세스인가?
- 프로세스의 작업 형태 고려
  - 일괄처리형 사용자들은 응답 시간이 좀 길어도 되지만, 대화형 사용자나 실시간 사용자들은 신속한 응답 시간이 보장되도록 스케줄링 한다.
- 프로세스의 우선순위 고려
  - 우선순위가 높은 프로세스들은 우선순위가 낮은 프로세스들보다 더 빨리 스케줄링 되도록 함.
- 프로세스의 버스트 시간 고려
  - 프로세스 작업의 형태와 버스트 시간에 따라 우선순위를 조정하도록 스케줄링 한다.
- 프로세스의 잔여 실행 시간 고려
  - 가장 적은 실행 시간을 남긴 프로세스를 먼저 실행시켜, 모든 프로세스의 평균대기 시간을 최소화하도록 스케줄링 한다.

CPU 스케줄링의 성능기준
* 특정 상황에 맞는 스케줄링 알고리즘을 선택하려면 다양한 알고리즘의 특성을 고려해 가장 적은 실행 시간
을 남긴 프로세스를 먼저 실행시켜 모든 프로세스의 평균대기 시간을 최소화하도록 스케줄링 해야 한다.
  - CPU 이용률
  - CPU 이용률
  - 반환시간
  - 대기시간
  - 응답시간

# 시험에 나옴
**선점 스케줄링**
* 하나의 프로세스가 CPU를 차지하고 있을 때 다른 프로세스가 현재 프로세스를 중단시키고 자신이 CPU를 차지할
수 있는 기법
* 높은 우선순위를 가진 프로세스들이 빠른 처리르 요구하는 시스템에서 유용하게 사용된다.
* 우선순위가 높은 프로세스가 먼저 수행할 때 유리하다.
* 빠른 응답시간을 요구하는 시분할 시스템에 유용하다.
* 선점으로 인한 많은 오버헤드를 초래한다.

**비선점 스케줄링**
* 한 프로세스가 CPU를 할당받으면 다른 프로세스는 CPU를 그 프로세스로부터 점유할 수 없는 기법
* 모든 프로세스들에 대한원칙은 짧은 작업이든 긴 작업이든 공정해야 함.
* 선점을 할 수 없는 자원들의 예 : printer, tape
* 모든 프로세스에 대한 요구를 공정히 처리한다.
* 응답시간의 예측이 가능하다.
* 짧은 작업이 긴 작업을 기다리는 경우가 자주 발생할 수 있다.

**우선순위 스케줄링 예제(내 카톡 사진참조)**
p2(1) - p5(2) - p3 or p1(3) - p1 or p3(3) - p4(4)

**기한부 스케줄링(비선점)**

**FCFS스케줄링(내 카톡 사진 참조)**
* 누가 먼저 왔는지 모르니 '도착 시간'을 추가함.(p1부터 순차적으로 0, 1, 2, 3)
* 대기시간
  * p1 : 0 
  * p2 : 23(1초에 도착한거 계산해서)
  * p3 : 25
  * p4 : 27
* 반환시간
  * p1 : 24
  * p2 : 26
  * p3 : 28
  * p4 : 37

**라운드 로빈(RR) 스케줄링**
