제네릭을 사용하는 코드의 이점
	* 컴파일 시 강한 타입 체크 가능
		실행시 타입 에러가 나는 것 방지
		컴파일 시에 미리 타입을 강하게 체크해서 에러 사전 방지

ex) List list = new ArrayList();
	list.add("hello");
	String str = (String) list.get(0);
	
generic) List<String> list ...

제네릭 타입이란?
	- 타입을 파라미터로 가지는 클래스와 인터페이스
	- 선언 시 클래스 또는 인터페이스 이름 뒤에 "<>" 부호 붙임
	- "<>" 사이에는 타입 파라미터 위치

타입 파라미터
	* 일반적으로 대문자 알파벳 한 문자로 표현
	* 개발 코드에서는 타입 파라미터 자리에 구체적으로 타입을 지정해야함.

제네릭 타입 사용 여부에 따른 비교
	* 제네릭 타입을 사용하지 않은 경우
		- object 타입 사용 -> 빈번한 타입 변환 발생 -> 프로그램 성능 저하

	* 제네릭 타입을 사용한 경우
		- 클래스 선언할 때 타입 파라미터 사용
		- 컴파일 시 타입 파라미터가 구체적인 클래스로 변경
	
제네릭 타입 사용 - 인터페이스
Rentable 인터페이스를 제네릭 타입으로 선언
	-렌트하기 위해 rent() 추상 메소드 선언
	-다양한 제품을 렌트하기 위해 리턴 타입을 타입 파라미터로 선언

List 컬렉션의 특징 및 주요 메소드
* 특징
	인덱스로 관리
	중복해서 객체 저장 가능
* 구현 클래스
ArrayList
Vector
LinkedList

ArrayList
초기 용량 : 10
저장용량을 초과한 객체들이 들어오면 자동적으로 늘어남. 고정도 가능

객체 제거
- 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨짐.

LinkedList
List<E> list = new LinkedList<E>();

특징
	* 인접 참조를 링크해서 체인처럼 관리
	* 특정 인덱스에서 객체를 제거하거나 추가하게 되면 바로 앞뒤 링크만 변경
	* 빈번한 객체 삭제와 삽입이 일어나는 곳에서는 ArrayList보다 좋은 성능

Set 컬렉션의 특징 및 주요 메소드

특징
	* 수학의 집합에 비유
	* 저장 순서가 유지되지 않음

Map 컬렉션 특징 및 주요 메소드

특징
* 키와 값으로 구성된 Map.Entry 객체를 저장하는 구조
* 키와 값은 모두 객체
* 키는 중복될 수 없지만 값은 중복 저장 가능.

구현 클래스 -> HashMap, Hashtable, TreeMap, Properties ...

HashMap

- 키 객체가 hashCode()의 린터값이 같고, equals() 메소드가 true를 리턴할 경우, 동일 키로 보고 중복 저장을 하지 않음
- 키 타입은 String 타입을 많이 사용
- String은 문자열이 같은 경우 동등 객체가 될 수 있도록 hashCode()와 equals() 메소드가 재정의 되어 있기 때문


Hashtable

* 키 객체 만드는 법은 HashMap과 동일함.
